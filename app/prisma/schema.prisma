generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

model Room {
  id        String    @id @default(cuid())
  secretId  String    @unique
  name      String
  createdAt DateTime  @default(now())
  meetings  Meeting[]

  @@index([secretId])
  @@map("rooms")
}

model Meeting {
  id           String        @id @default(cuid())
  roomId       String
  room         Room          @relation(fields: [roomId], references: [id], onDelete: Cascade)
  startedAt    DateTime      @default(now())
  endedAt      DateTime?
  status       MeetingStatus @default(IN_PROGRESS)
  participants Participant[]
  utterances   Utterance[]
  recordings   Recording[]
  egresses     Egress[]

  @@index([roomId])
  @@index([status])
  @@map("meetings")
}

model Participant {
  id         String      @id @default(cuid())
  meetingId  String
  meeting    Meeting     @relation(fields: [meetingId], references: [id], onDelete: Cascade)
  name       String
  identity   String      // LiveKit participant identity
  joinedAt   DateTime    @default(now())
  leftAt     DateTime?
  utterances Utterance[]
  recordings Recording[]
  egresses   Egress[]

  @@unique([meetingId, identity])
  @@index([meetingId])
  @@map("participants")
}

model Utterance {
  id            String      @id @default(cuid())
  meetingId     String
  meeting       Meeting     @relation(fields: [meetingId], references: [id], onDelete: Cascade)
  participantId String
  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade)
  text          String      @db.Text
  startTime     Float       // Seconds from meeting start
  endTime       Float       // Seconds from meeting start
  createdAt     DateTime    @default(now())

  @@index([meetingId])
  @@index([participantId])
  @@index([startTime])
  @@map("utterances")
}

model Recording {
  id            String      @id @default(cuid())
  meetingId     String
  meeting       Meeting     @relation(fields: [meetingId], references: [id], onDelete: Cascade)
  participantId String
  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade)
  fileUrl       String      // S3/MinIO URL
  fileName      String      // Original file name
  duration      Float       // Duration in seconds
  startedAt     DateTime?   // When the recording actually started (from LiveKit Egress)
  transcribed   Boolean     @default(false)
  createdAt     DateTime    @default(now())

  @@index([meetingId])
  @@index([participantId])
  @@index([transcribed])
  @@map("recordings")
}

enum MeetingStatus {
  IN_PROGRESS
  PROCESSING
  COMPLETED
  FAILED
}

model Egress {
  id            String       @id @default(cuid())
  egressId      String       @unique // LiveKit egress ID
  meetingId     String
  meeting       Meeting      @relation(fields: [meetingId], references: [id], onDelete: Cascade)
  participantId String
  participant   Participant  @relation(fields: [participantId], references: [id], onDelete: Cascade)
  trackSid      String
  status        EgressStatus @default(ACTIVE)
  createdAt     DateTime     @default(now())
  completedAt   DateTime?

  @@index([meetingId])
  @@index([status])
  @@map("egresses")
}

enum EgressStatus {
  ACTIVE
  COMPLETED
  FAILED
}
